/*
 Copyright 2016 Goldman Sachs.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */

/* Generated By:JJTree&JavaCC: Do not edit this line. MithraQL.java */
package com.gs.fw.common.mithra.generator.queryparser;
import java.io.FileInputStream;
public class MithraQL/*@bgen(jjtree)*/implements MithraQLTreeConstants, MithraQLConstants {/*@bgen(jjtree)*/
  protected JJTMithraQLState jjtree = new JJTMithraQLState();

  final public ASTCompilationUnit CompilationUnit() throws ParseException {
 /*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      OrExpression();
      jj_consume_token(0);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void AttributeName() throws ParseException {
 /*@bgen(jjtree) AttributeName */
        ASTAttributeName jjtn000 = new ASTAttributeName(JJTATTRIBUTENAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        String name;
    try {
      t = jj_consume_token(IDENTIFIER);
                          name = t.image;
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        t = jj_consume_token(DOT);
                                                        name += t;
        t = jj_consume_token(IDENTIFIER);
                                                                                      name +=t;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(name);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void RelationalOperator() throws ParseException {
 /*@bgen(jjtree) RelationalOperator */
  ASTRelationalOperator jjtn000 = new ASTRelationalOperator(JJTRELATIONALOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        jj_consume_token(EQUAL);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 jjtn000.setEqual(true); jjtn000.setString("=");
        break;
      case NOTEQUAL:
        jj_consume_token(NOTEQUAL);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                    jjtn000.setNotEqual(true); jjtn000.setString("!=");
        break;
      case GREATER_THAN:
        jj_consume_token(GREATER_THAN);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                        jjtn000.setGreaterThan(true); jjtn000.setString(">");
        break;
      case LESSER_THAN:
        jj_consume_token(LESSER_THAN);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       jjtn000.setLesserThan(true); jjtn000.setString("<");
        break;
      case GREATER_THAN_EQUAL:
        jj_consume_token(GREATER_THAN_EQUAL);
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                              jjtn000.setGreaterThanOrEqualTo(true); jjtn000.setString(">=");
        break;
      case LESSER_THAN_EQUAL:
        jj_consume_token(LESSER_THAN_EQUAL);
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                             jjtn000.setLesserThanOrEqualTo(true); jjtn000.setString("<=");
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void InOperator() throws ParseException {
 /*@bgen(jjtree) InOperator */
  ASTInOperator jjtn000 = new ASTInOperator(JJTINOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IN);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void OrExpression() throws ParseException {
          ASTOrExpression jjtn001 = new ASTOrExpression(JJTOREXPRESSION);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
    try {
      AndExpression();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        jj_consume_token(OR);
        AndExpression();
      }
    } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte001;}
          }
          if (jjte001 instanceof ParseException) {
            {if (true) throw (ParseException)jjte001;}
          }
          {if (true) throw (Error)jjte001;}
    } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
    }
  }

  final public void AndExpression() throws ParseException {
      ASTAndExpression jjtn001 = new ASTAndExpression(JJTANDEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case BOOLEAN_LITERAL:
      case JAVA_LITERAL:
      case IDENTIFIER:
        RelationalExpression();
        break;
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        OrExpression();
        jj_consume_token(CLOSE_PAREN);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        jj_consume_token(AND);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case CHARACTER_LITERAL:
        case BOOLEAN_LITERAL:
        case JAVA_LITERAL:
        case IDENTIFIER:
          RelationalExpression();
          break;
        case OPEN_PAREN:
          jj_consume_token(OPEN_PAREN);
          OrExpression();
          jj_consume_token(CLOSE_PAREN);
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
  }

  final public void RelationalExpression() throws ParseException {
 /*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      SimpleExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case NOTEQUAL:
      case GREATER_THAN:
      case LESSER_THAN:
      case GREATER_THAN_EQUAL:
      case LESSER_THAN_EQUAL:
        RelationalOperatorExpression();
        break;
      case IS:
        IsNullClause();
        break;
      case IN:
        InExpression();
        break;
      case EQUALSEDGEPOINT:
        equalsEdgePointClause();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void RelationalOperatorExpression() throws ParseException {
    RelationalOperator();
    SimpleExpression();
  }

  final public void SimpleExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      AttributeName();
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case JAVA_LITERAL:
      Literal();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void InExpression() throws ParseException {
    InOperator();
    InLiteral();
  }

  final public void IsNullClause() throws ParseException {
 /*@bgen(jjtree) IsNullClause */
  ASTIsNullClause jjtn000 = new ASTIsNullClause(JJTISNULLCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
           jjtn000.setNot(true);
        jj_consume_token(NOT);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jj_consume_token(NULL);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void equalsEdgePointClause() throws ParseException {
 /*@bgen(jjtree) equalsEdgePointClause */
  ASTequalsEdgePointClause jjtn000 = new ASTequalsEdgePointClause(JJTEQUALSEDGEPOINTCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EQUALSEDGEPOINT);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
            jjtn000.setInteger(true);
                jjtn000.setValue(t.image);
        break;
      case FLOATING_POINT_LITERAL:
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                jjtn000.setFloatingPoint(true);
                jjtn000.setValue(t.image);
        break;
      case STRING_LITERAL:
        t = jj_consume_token(STRING_LITERAL);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                jjtn000.setString(true);
                jjtn000.setValue(t.image);
        break;
      case CHARACTER_LITERAL:
        t = jj_consume_token(CHARACTER_LITERAL);
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                jjtn000.setCharacter(true);
                jjtn000.setValue(t.image);
        break;
      case BOOLEAN_LITERAL:
        t = jj_consume_token(BOOLEAN_LITERAL);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                jjtn000.setBoolean(true);
                jjtn000.setValue(t.image);
        break;
      case JAVA_LITERAL:
        t = jj_consume_token(JAVA_LITERAL);
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                jjtn000.setJavaLiteral(true);
                jjtn000.setValue(t.image);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void InLiteral() throws ParseException {
 /*@bgen(jjtree) InLiteral */
  ASTInLiteral jjtn000 = new ASTInLiteral(JJTINLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String value;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          t = jj_consume_token(STRING_LITERAL);
                              value = t.image;
          label_4:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[10] = jj_gen;
              break label_4;
            }
            t = jj_consume_token(COMMA);
                                                              value += t.image;
            t = jj_consume_token(STRING_LITERAL);
                                                                                                       value += t.image;
          }
                        jjtn000.setValue(value);
          break;
        case INTEGER_LITERAL:
          t = jj_consume_token(INTEGER_LITERAL);
                               value = t.image;
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[11] = jj_gen;
              break label_5;
            }
            t = jj_consume_token(COMMA);
                                                               value += t.image;
            t = jj_consume_token(INTEGER_LITERAL);
                                                                                                         value += t.image;
          }
                        jjtn000.setValue(value);
          break;
        case CHARACTER_LITERAL:
          t = jj_consume_token(CHARACTER_LITERAL);
                                 value = t.image;
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[12] = jj_gen;
              break label_6;
            }
            t = jj_consume_token(COMMA);
                                                                 value += t.image;
            t = jj_consume_token(CHARACTER_LITERAL);
                                                                                                             value += t.image;
          }
                        jjtn000.setValue(value);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(CLOSE_PAREN);
        break;
      case JAVA_LITERAL:
        t = jj_consume_token(JAVA_LITERAL);
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
            jjtn000.setValue(t.image);
            jjtn000.setIsJavaLiteral(true);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  public MithraQLTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[15];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x10000,0x7e0000,0x80,0xd8800000,0x40,0xd8800000,0x47e0c00,0xd8000000,0x100,0xd8000000,0x2000000,0x2000000,0x2000000,0xc8000000,0x800000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x7,0x0,0x3,0x0,0x0,0x0,0x0,0x2,};
   }

  public MithraQL(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MithraQLTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public MithraQL(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MithraQLTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public MithraQL(MithraQLTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  public void ReInit(MithraQLTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 15; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[37];
    for (int i = 0; i < 37; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 15; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 37; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
