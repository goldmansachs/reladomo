/*
 Copyright 2016 Goldman Sachs.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */

/* Generated By:JJTree: Do not edit this line. ASTAttributeName.java */


package com.gs.fw.common.mithra.generator.queryparser;

import com.gs.fw.common.mithra.generator.AbstractAttribute;
import com.gs.fw.common.mithra.generator.MithraObjectTypeWrapper;

import java.util.List;
import java.util.Map;
import java.util.Set;

public class ASTAttributeName extends SimpleNode
{
    private String name;
    private AbstractAttribute attribute;
    private boolean belongsToThis;
    private MithraObjectTypeWrapper owner;

    public ASTAttributeName(int id) {
        super(id);
    }

    public ASTAttributeName(MithraQL p, int id) {
        super(p, id);
    }

    public ASTAttributeName(AbstractAttribute left, boolean belongsToThis)
    {
        super(0);
        this.belongsToThis = belongsToThis;
        this.attribute = left;
        this.owner = left.getOwner();
        if (belongsToThis)
        {
            this.name = "this."+this.attribute.getName();
        }
        else
        {
            this.name = this.owner.getClassName() +"."+ this.attribute.getName();
        }
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return this.name;
    }

    public void checkConsistency(MithraObjectTypeWrapper owner, Map allObjects, List<String> errors)
    {
        if (this.attribute != null) return;
        String error = this.findAttribute(owner, allObjects);
        if (error != null) errors.add(error);
    }

    public void addImport(MithraObjectTypeWrapper owner, Map allObjects, List<String> errors)
    {
        String[] nameSplit = this.getName().split("\\.");
        if (nameSplit.length == 2)
        {
            String className = nameSplit[0];
            if (!className.equals("this"))
            {
                MithraObjectTypeWrapper wrapper = (MithraObjectTypeWrapper) allObjects.get(className);
                owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getDataClassName());
                owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getClassName());
                owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getAbstractClassName());
                owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getFinderClassName());
                owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getListClassName());
                if(wrapper.isGenerateInterfaces())
                {
                    owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getListInterfaceName());
                    owner.addToRequiredClasses(wrapper.getPackageName(), wrapper.getImplClassName());
                }
            }
        }
        else
        {
            if (errors != null) errors.add("Attribute '" + this.getName() + "' is not in [className.attribute] format" + nameSplit.length);
        }
    }

    public String findAttribute(MithraObjectTypeWrapper owner, Map allObjects)
    {
        String[] nameSplit = this.getName().split("\\.");
        if (nameSplit.length == 2)
        {
            String className = nameSplit[0];
            String attributeName = nameSplit[1];
            if (className.equals("this"))
            {
                className = owner.getClassName();
                this.belongsToThis = true;
                this.owner = owner;
            }
            if (!allObjects.containsKey(className))
            {
                return "Class name '" + className + "'" + "not defined. Have you added a xml file for this class?";
            }
            else
            {
                MithraObjectTypeWrapper wrapper = (MithraObjectTypeWrapper) allObjects.get(className);
                this.owner = wrapper;
                this.attribute = wrapper.getAttributeByName(attributeName);
                if (this.attribute == null)
                {
                    return "Attribute '" + attributeName + "' does not exist in class '" + className + "'";
                }
            }
            return null;
        }
        else
        {
            return "Attribute '" + this.getName() + "' is not in [className.attribute] format" + nameSplit.length;
        }
    }

    public boolean isSourceAttribute()
    {
        return this.attribute.isSourceAttribute();
    }

    public boolean isAsOfAttribute()
    {
        return this.attribute.isAsOfAttribute();
    }

    public AbstractAttribute getAttribute()
    {
        return this.attribute;
    }

    public boolean isComparableTo(ASTAttributeName other)
    {
        return this.getAttribute().isComparableTo(other.getAttribute());
    }

    public boolean isComparableTo(ASTLiteral other)
    {
        return this.getAttribute().isComparableTo(other);
    }

    public boolean belongsToThis()
    {
        return this.belongsToThis;
    }

    public MithraObjectTypeWrapper getOwner()
    {
        return this.owner;
    }

    public String getTopLevelFinderAttribute()
    {
        return this.owner.getClassName()+"Finder."+this.getAttribute().getName()+"()";
    }

    public String getFinderString()
    {
        return this.getTopLevelFinderAttribute();
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(MithraQLVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public void addDependentClassesToSet(Set set)
    {
        super.addDependentClassesToSet(set);
        if (!this.belongsToThis) set.add(this.owner);
    }

	public String getArgumentForInOperation(String values, MithraObjectTypeWrapper fromObject)
	{
		return this.getAttribute().getType().getArgumentForInOperation(values, fromObject);
	}

    public boolean equalsOther(SimpleNode other)
    {
        if (other instanceof ASTAttributeName)
        {
            AbstractAttribute otherAttr = ((ASTAttributeName)other).getAttribute();
            return this.getAttribute().getName().equals(otherAttr.getName()) && this.getOwner().getClassName().equals(otherAttr.getOwner().getClassName());
        }
        return false;
    }
}

