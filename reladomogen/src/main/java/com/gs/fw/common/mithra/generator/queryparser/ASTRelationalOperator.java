/*
 Copyright 2016 Goldman Sachs.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */

/* Generated By:JJTree: Do not edit this line. ASTRelationalOperator.java */


package com.gs.fw.common.mithra.generator.queryparser;

public class ASTRelationalOperator extends SimpleNode implements Operator
{
    private boolean equal;
    private boolean notEqual;
    private boolean greaterThan;
    private boolean lesserThan;
    private boolean greaterThanOrEqualTo;
    private boolean lesserThanOrEqualTo;
    private String string;

	public boolean isIsNullOrIsNotNull()
	{
		return false;
	}

    @Override
    public boolean isIsNotNull()
    {
        return false;
    }

    public boolean isGreaterThan()
    {
        return greaterThan;
    }

    public void setGreaterThan(boolean greaterThan)
    {
        this.greaterThan = greaterThan;
    }

    public boolean isLesserThan()
    {
        return lesserThan;
    }

    public void setLesserThan(boolean lesserThan)
    {
        this.lesserThan = lesserThan;
    }

    public boolean isGreaterThanOrEqualTo()
    {
        return greaterThanOrEqualTo;
    }

    public void setGreaterThanOrEqualTo(boolean greaterThanOrEqualTo)
    {
        this.greaterThanOrEqualTo = greaterThanOrEqualTo;
    }

    public boolean isLesserThanOrEqualTo()
    {
        return lesserThanOrEqualTo;
    }

    public void setLesserThanOrEqualTo(boolean lesserThanOrEqualTo)
    {
        this.lesserThanOrEqualTo = lesserThanOrEqualTo;
    }

    public ASTRelationalOperator(int id) {
        super(id);
    }

    public ASTRelationalOperator(MithraQL p, int id) {
        super(p, id);
    }

    public boolean isEqual() {
        return equal;
    }

    public void setEqual(boolean equal) {
        this.equal = equal;
    }

    public boolean isNotEqual() {
        return notEqual;
    }

    public void setNotEqual(boolean notEqual) {
        this.notEqual = notEqual;
    }

    public String toString() {
        return string;
    }

    public void setString(String string)
    {
        this.string = string;
    }

    public Operator getReverseOperator()
    {
        // todo: rezaem: take care of cases where we have to flip (greater than, etc)
        return this;
    }

	public boolean isIn()
	{
		return false;
	}

    public String getPrimitiveOperator()
    {
        if (this.isEqual())
        {
            return " == ";
        }
        else if(this.isLesserThan())
        {
            return " < ";
        }
        else if(this.isLesserThanOrEqualTo())
        {
            return " <= ";
        }
        else if(this.isGreaterThan())
        {
            return " > ";
        }
        else if(this.isGreaterThanOrEqualTo())
        {
            return " >= ";
        }
        else if (this.isNotEqual())
        {
            return " != ";
        }
        throw new RuntimeException("relational operator '" + this.toString() + "' not implemented");
    }

    public String getMethodName()
    {
        if (this.isEqual())
        {
            return "eq";
        }
        else if(this.isLesserThan())
        {
            return "lessThan";
        }
        else if(this.isLesserThanOrEqualTo())
        {
            return "lessThanEquals";
        }
        else if(this.isGreaterThan())
        {
            return "greaterThan";
        }
        else if(this.isGreaterThanOrEqualTo())
        {
            return "greaterThanEquals";
        }
        else if (this.isNotEqual())
        {
            return "notEq";
        }
        throw new RuntimeException("relational operator '" + this.toString() + "' not implemented");
    }
    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(MithraQLVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public boolean equalsOther(SimpleNode other)
    {
        if (other instanceof ASTRelationalOperator)
        {
            return ((ASTRelationalOperator)other).getMethodName().equals(this.getMethodName());
        }
        return false;
    }

    public boolean isUnary()
    {
        return false;
    }

    public boolean isEqualsEdgePoint()
    {
        return false;
    }

    public String getPrimitiveExpression(String left, String right)
    {
        return left + this.getPrimitiveOperator() + right;
    }

    public String getNonPrimitiveExpression(String left, String right)
    {
        String result = left+" != null && ";
        if (this.isEqual())
        {
            result +=  left+".equals("+right+")";
        }
        else if(this.isLesserThan())
        {
            result +=  left+".compareTo("+right+") < 0";
        }
        else if(this.isLesserThanOrEqualTo())
        {
            result +=  left+".compareTo("+right+") <= 0";
        }
        else if(this.isGreaterThan())
        {
            result +=  left+".compareTo("+right+") > 0";
        }
        else if(this.isGreaterThanOrEqualTo())
        {
            result +=  left+".compareTo("+right+") >= 0";
        }
        else if (this.isNotEqual())
        {
            result +=  "!"+left+".equals("+right+")";
        }
        else
        {
            throw new RuntimeException("relational operator '" + this.toString() + "' not implemented");
        }
        return result;
    }
}
